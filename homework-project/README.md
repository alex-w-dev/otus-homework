### решение ДЗ:

Доброго времени суток!  
Вот мой рецепт идемпотентности для заказа:

1. HTTP метод создания идемпотентен:

   - первый вызов создает заказ
   - второй упадет с ошибкой "такой заказ уже существует", если все данные заказа (продукты, курьер, место выдачи и пр.) идентичны существуюущему в БД (проверяются заказы "моложе" 10 минут), но что если клиент действительно хочет дублировать заказ? вот ответ:
     - если передать doubleAccepted в теле запроса, то проверка не будет проведена, но это должно быть реализовано на клиенте: подтверждение "подобный заказ уже создан, создать новый?"
     - если сделать заказ позднее 10 минут* с аналогичными данными, то будет создан второй заказ с аналогичными параметрами без "предупреждения".  
       *Время взято примерное, можно заменить на 1 час, например.

2. Все подписчики событий саги реализуют идемпотентность без вызова ошибки (компенсации саги не будет, если сообщение выполняется не первый раз). <strong>Ключем идемпотентности явлется orderId</strong>.

   - Каждый сервис обрабатывающий сагу, сперва проверяет наличие записей внутри себя отностильно orderId: если записи есть, то ничего не происходит, событие пробрасывается дальше.
   - И даже если у нас будет "зомби", то мы успешно пройдемся, хоть 10 раз, по саге и результат будет 1 - тот который первый обновил БД.
   - Случай "компенсации саги" и затем заупуска её снова, также предусматривается: события не пробрасываются.
   - Параллельный вызов обработчиков также фиксирован транзакциями в БД.
   - Аналогично и компенсация саги не проходит дважды.

   Всё это достигается путем сохранения транзакционных данных на каждом из шагов в микросервисах и их ответсвенностью за соблюдение идемпотентности.

   Такой подход отлично работает при случаях потери сообщений - сагу можно запустить с самого начала. (я на работе делал подобное, только там нужно было поднимать инфраструктуру разработки: можно было запустить с самого начала сколько угодно раз, но ресурсы создавались только 1 раз)

#### Что нужно для запуска:

- Minikube (также включить ingress addon)
- Helm
- Newman (тестирование запущенного приложения)

#### Начинаем:

(-2) Grafan UI: `minikube service homework-project-grafana -n homework-project`

(-1) Не забудь запустить minikube: `minikube start`
(0) работаем из директории homework-project: `cd ./homework-project` ... если вы не в ней

(1) Устанавливаем наш хелм чарт , который имеет в себе инструкции по запуску нашего приложения (неймспейс `homework-project`):

```bash
helm upgrade homework-project --install --create-namespace --namespace=homework-project ./app
```

(1.1) Дамашняя работа в неймспейсе `homework-project`, поэтому сменим неймспейс, если будете пользоваться kubectl, minikube или helm:  
`kubectl config set-context --current --namespace=homework-project`

(2) Не забываем включить тунель в отдельном окне терминала и настроить hosts:

```bash
minikube tunnel
```

(3) Теперь Newman поможет протестировать коллекцию Postman, которая ссылается на наше локальное приложение (`--verbose` для отображения деталей):

```bash
newman run otus-homework-project.postman_collection.json --verbose
```

Ниже вот такие логи у меня локально:

```

```
